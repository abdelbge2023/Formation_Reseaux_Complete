<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Calculateur VLSM avec Explications Binaires</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background: #f0f2f5; }
header { background: #4CAF50; color: #fff; padding: 20px; text-align: center; font-size: 24px; font-weight: bold; }
nav { background: #333; color: #fff; padding: 10px; position: sticky; top: 0; display: flex; gap: 15px; flex-wrap: wrap; }
nav button { background: #555; border: none; padding: 8px 12px; color: #fff; cursor: pointer; border-radius: 4px; }
nav button:hover { background: #777; }
section { padding: 20px; }
label { display: inline-block; width: 160px; margin-top: 10px; }
input { margin: 5px; padding: 5px; width: 150px; }
button.action { margin: 5px; padding: 8px 12px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; }
button.action:hover { background: #45a049; }
table { border-collapse: collapse; width: 100%; margin-top: 20px; background: #fff; }
th, td { border: 1px solid #999; padding: 8px; text-align: center; }
th { background: #eee; }
#hostsInputs input { width: 80px; }
#barContainer { margin-top: 30px; width: 100%; height: 50px; background: #ddd; border-radius: 5px; position: relative; }
.barSegment { height: 100%; position: absolute; text-align: center; color: #fff; font-weight: bold; line-height: 50px; border-radius: 5px 0 0 5px; overflow: hidden; cursor: pointer; transition: all 0.2s; }
.barSegment:hover { opacity: 0.8; transform: scaleY(1.1); }
.tooltip { position: absolute; background: #333; color: #fff; padding: 5px 8px; border-radius: 4px; font-size: 12px; display: none; pointer-events: none; z-index: 1000; }
.alert { color: red; font-weight: bold; margin-top: 10px; }
.total { margin-top: 15px; font-weight: bold; font-size: 16px; }
.input-group { margin-bottom: 10px; }
.example { background: #e7f3ff; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 14px; }
.explanation { background: #fff3cd; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #ffc107; }
.explanation h3 { margin-top: 0; color: #856404; }
.explanation-step { margin: 10px 0; padding: 10px; background: #fff; border-radius: 4px; }
.calculation { font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 3px; margin: 5px 0; border: 1px solid #dee2e6; }
.formula { color: #d63384; font-weight: bold; }
.binary-explanation { background: #e8f5e8; padding: 10px; border-radius: 5px; margin: 10px 0; font-family: 'Courier New', monospace; }
.binary-row { display: flex; align-items: center; margin: 5px 0; }
.binary-bits { display: flex; gap: 2px; margin: 0 10px; }
.bit { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 1px solid #999; }
.bit-1 { background: #4CAF50; color: white; }
.bit-0 { background: #f8f9fa; color: #333; }
.network-bit { background: #2196F3; color: white; }
.host-bit { background: #FF9800; color: white; }
.binary-label { min-width: 120px; font-weight: bold; }
.binary-separator { margin: 0 5px; color: #666; }
.toggle-binary { background: #6c757d; margin-left: 10px; }
.toggle-binary:hover { background: #5a6268; }
</style>
</head>
<body>

<header>Calculateur VLSM Professionnel</header>

<nav>
  <button onclick="scrollToSection('formSection')">Formulaire</button>
  <button onclick="scrollToSection('explanationSection')">Explications</button>
  <button onclick="scrollToSection('binarySection')">Vue Binaire</button>
  <button onclick="scrollToSection('resultSection')">Résultats</button>
  <button onclick="scrollToSection('graphSection')">Graphique</button>
  <footer>Version Web (El azhari Amazzale Abdelhadi)</footer>
</nav>

<section id="formSection">
<h2>Saisie des données</h2>

<div class="example">
  <strong>Exemple :</strong> Réseau: 192.168.0.0, Masque: /22, Sous-réseaux: 4, Hôtes: 250, 120, 60, 30
</div>

<div class="input-group">
  <label>Adresse réseau :</label>
  <input type="text" id="network" placeholder="ex: 192.168.0.0">
</div>

<div class="input-group">
  <label>Masque :</label>
  <input type="text" id="mask" placeholder="ex: 255.255.252.0 ou /22">
</div>

<div class="input-group">
  <label>Nombre de sous-réseaux :</label>
  <input type="number" id="nbSubnets" min="1">
</div>

<div id="hostsInputs"></div>

<button class="action" onclick="generateHostInputs()">Générer les champs</button>
<button class="action" onclick="calculateVLSM()">Calculer VLSM</button>
<button class="action" onclick="showExplanations()">Voir les explications</button>
<button class="action" onclick="showBinaryView()">Vue Binaire</button>
<button class="action" onclick="exportExcel()">Exporter Excel</button>
<button class="action" onclick="exportPDF()">Exporter PDF</button>
<div id="alertContainer" class="alert"></div>
</section>

<section id="explanationSection" style="display: none;">
<h2>Explications détaillées du calcul VLSM</h2>
<div id="calculationExplanations"></div>
</section>

<section id="binarySection" style="display: none;">
<h2>Représentation Binaire des Sous-réseaux</h2>
<div id="binaryExplanations"></div>
</section>

<section id="resultSection">
<h2>Tableau des sous-réseaux</h2>
<div id="result"></div>
<div id="totalHosts" class="total"></div>
</section>

<section id="graphSection">
<h2>Représentation graphique</h2>
<div id="barContainer"></div>
<div class="tooltip" id="tooltip"></div>
</section>

<script>
// ------------------ Variables globales ------------------
let lastResult = [];
let calculationSteps = [];
let binaryData = [];

// ------------------ Navigation ------------------
function scrollToSection(id){
  document.getElementById(id).scrollIntoView({behavior:'smooth'});
}

// ------------------ Utilitaires Binaires ------------------
function ipToBinary(ip) {
  const parts = ip.split('.').map(Number);
  return parts.map(part => part.toString(2).padStart(8, '0')).join('');
}

function binaryToIp(binary) {
  const octets = [];
  for (let i = 0; i < 32; i += 8) {
    octets.push(parseInt(binary.substr(i, 8), 2));
  }
  return octets.join('.');
}

function maskToBinary(prefix) {
  let binary = '';
  for (let i = 0; i < 32; i++) {
    binary += i < prefix ? '1' : '0';
  }
  return binary;
}

function createBinaryDisplay(label, binary, networkBits = 0, subnetBits = 0) {
  const bits = binary.split('');
  let html = `<div class="binary-row">
    <div class="binary-label">${label}:</div>
    <div class="binary-bits">`;
  
  bits.forEach((bit, index) => {
    let bitClass = 'bit';
    if (index < networkBits) {
      bitClass += ' network-bit';
    } else if (index < networkBits + subnetBits) {
      bitClass += ' bit-1';
    } else if (bit === '1') {
      bitClass += ' bit-1';
    } else {
      bitClass += ' bit-0';
    }
    
    // Ajouter des séparateurs tous les 8 bits
    if (index > 0 && index % 8 === 0) {
      html += `<span class="binary-separator">.</span>`;
    }
    
    html += `<div class="${bitClass}">${bit}</div>`;
  });
  
  html += `</div></div>`;
  return html;
}

// ------------------ Utilitaires ------------------
function maskToPrefix(mask) {
  if (!mask) return null;
  
  if (mask.startsWith("/")) {
    const prefix = parseInt(mask.slice(1));
    return (prefix >= 0 && prefix <= 32) ? prefix : null;
  }
  
  const parts = mask.split(".").map(Number);
  if (parts.length !== 4 || parts.some(p => isNaN(p) || p < 0 || p > 255)) {
    return null;
  }
  
  const binary = parts.map(p => p.toString(2).padStart(8, "0")).join("");
  const firstZero = binary.indexOf("0");
  if (firstZero === -1) return 32;
  
  if (binary.indexOf("1", firstZero) !== -1) {
    return null;
  }
  
  return firstZero;
}

function ipToInt(ip) {
  if (!ip) return null;
  const parts = ip.split(".").map(Number);
  if (parts.length !== 4 || parts.some(p => isNaN(p) || p < 0 || p > 255)) {
    return null;
  }
  return parts.reduce((a, b) => a * 256 + b, 0);
}

function intToIp(int) {
  return [(int >> 24) & 255, (int >> 16) & 255, (int >> 8) & 255, int & 255].join(".");
}

function isValidIP(ip) {
  const regex = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!regex.test(ip)) return false;
  const parts = ip.split(".").map(Number);
  return parts.every(p => p >= 0 && p <= 255);
}

// ------------------ Générer champs hôtes ------------------
function generateHostInputs() {
  const nb = parseInt(document.getElementById("nbSubnets").value);
  if (isNaN(nb) || nb < 1) {
    alert("Veuillez entrer un nombre valide de sous-réseaux");
    return;
  }
  
  const div = document.getElementById("hostsInputs");
  div.innerHTML = "";
  for (let i = 0; i < nb; i++) {
    div.innerHTML += `<div class="input-group">Hôtes SR${i+1}: <input type="number" id="hosts${i}" min="1"></div>`;
  }
}

// ------------------ Afficher les explications ------------------
function showExplanations() {
  if (calculationSteps.length === 0) {
    alert("Calculez d'abord les sous-réseaux pour voir les explications !");
    return;
  }
  
  document.getElementById('explanationSection').style.display = 'block';
  scrollToSection('explanationSection');
}

function showBinaryView() {
  if (binaryData.length === 0) {
    alert("Calculez d'abord les sous-réseaux pour voir la vue binaire !");
    return;
  }
  
  document.getElementById('binarySection').style.display = 'block';
  scrollToSection('binarySection');
}

// ------------------ Calcul VLSM avec explications ------------------
function calculateVLSM() {
  const network = document.getElementById("network").value.trim();
  const mask = document.getElementById("mask").value.trim();
  const nb = parseInt(document.getElementById("nbSubnets").value);
  const alertDiv = document.getElementById("alertContainer");
  alertDiv.innerHTML = "";
  calculationSteps = [];
  binaryData = [];
  
  // Validation des entrées
  if (!network || !mask || isNaN(nb) || nb < 1) {
    alert("Remplissez tous les champs correctement");
    return;
  }
  
  if (!isValidIP(network)) {
    alert("Adresse réseau invalide");
    return;
  }
  
  const prefix = maskToPrefix(mask);
  if (prefix === null) {
    alert("Masque invalide");
    return;
  }
  
  const networkInt = ipToInt(network);
  if (networkInt === null) {
    alert("Adresse réseau invalide");
    return;
  }
  
  // Récupération des nombres d'hôtes
  const hosts = [];
  for (let i = 0; i < nb; i++) {
    const hostInput = document.getElementById(`hosts${i}`);
    if (!hostInput) {
      alert("Générez d'abord les champs pour les hôtes");
      return;
    }
    
    const h = parseInt(hostInput.value);
    if (isNaN(h) || h < 1) {
      alert(`Veuillez entrer un nombre valide d'hôtes pour le sous-réseau ${i+1}`);
      return;
    }
    hosts.push({hosts: h, index: i});
  }
  
  // Données binaires pour le réseau principal
  binaryData.push({
    type: 'main',
    network: network,
    mask: prefix,
    binaryNetwork: ipToBinary(network),
    binaryMask: maskToBinary(prefix)
  });

  // Explication 1: Analyse du réseau principal
  calculationSteps.push({
    title: "1. Analyse du réseau principal",
    content: `
      <div class="calculation">
        <strong>Réseau principal :</strong> ${network}/${prefix}<br>
        <strong>Adresse réseau :</strong> ${network}<br>
        <strong>Masque CIDR :</strong> /${prefix}<br>
        <strong>Nombre total d'adresses :</strong> 2<sup>${32-prefix}</sup> = ${Math.pow(2, 32-prefix)} adresses<br>
        <strong>Nombre d'hôtes utilisables :</strong> ${Math.pow(2, 32-prefix) - 2} hôtes
      </div>
      <div class="binary-explanation">
        <strong>Représentation binaire :</strong><br>
        ${createBinaryDisplay('Réseau', ipToBinary(network), prefix, 0)}
        ${createBinaryDisplay('Masque', maskToBinary(prefix), prefix, 0)}
        <div style="margin-top: 10px; font-size: 12px;">
          <span style="background: #2196F3; color: white; padding: 2px 5px;">Bits réseau</span>
          <span style="background: #FF9800; color: white; padding: 2px 5px; margin-left: 5px;">Bits hôte</span>
        </div>
      </div>
    `
  });
  
  // Tri décroissant pour l'allocation VLSM
  hosts.sort((a, b) => b.hosts - a.hosts);
  
  // Calcul des sous-réseaux
  lastResult = [];
  let resultHtml = "<table><tr><th>SR</th><th>Réseau</th><th>Masque</th><th>Hôtes max</th><th>Première IP</th><th>Dernière IP</th><th>Broadcast</th></tr>";
  let currentAddress = networkInt;
  let totalHosts = 0;
  const colors = ["#4CAF50", "#2196F3", "#FF9800", "#9C27B0", "#E91E63", "#00BCD4", "#FF5722", "#8BC34A"];
  
  const totalNetworkSize = Math.pow(2, 32 - prefix);
  const networkEnd = networkInt + totalNetworkSize - 1;
  
  let hasOverflow = false;
  
  for (let i = 0; i < hosts.length; i++) {
    const neededHosts = hosts[i].hosts;
    const originalIndex = hosts[i].index;
    
    // Calcul du nouveau préfixe pour ce sous-réseau
    const neededAddresses = neededHosts + 2;
    const newPrefix = 32 - Math.ceil(Math.log2(neededAddresses));
    const subnetSize = Math.pow(2, 32 - newPrefix);
    const subnetBits = newPrefix - prefix;
    
    // Vérifier la capacité
    if (currentAddress + subnetSize > networkEnd + 1) {
      alertDiv.innerHTML = "⚠️ Attention : Le réseau principal est trop petit !";
      hasOverflow = true;
      break;
    }
    
    // Calcul des adresses
    const networkAddr = currentAddress;
    const firstUsable = networkAddr + 1;
    const lastUsable = networkAddr + subnetSize - 2;
    const broadcastAddr = networkAddr + subnetSize - 1;
    
    totalHosts += neededHosts;
    
    // Stocker les données binaires
    binaryData.push({
      type: 'subnet',
      sr: originalIndex + 1,
      network: intToIp(networkAddr),
      mask: newPrefix,
      binaryNetwork: ipToBinary(intToIp(networkAddr)),
      binaryMask: maskToBinary(newPrefix),
      subnetBits: subnetBits,
      hostBits: 32 - newPrefix
    });

    // Explication détaillée pour chaque sous-réseau
    calculationSteps.push({
      title: `2.${i+1} Sous-réseau ${originalIndex + 1} (${neededHosts} hôtes)`,
      content: `
        <div class="calculation">
          <strong>Hôtes demandés :</strong> ${neededHosts}<br>
          <strong>Adresses nécessaires :</strong> ${neededHosts} + 2 = ${neededAddresses}<br>
          <strong>Nouveau préfixe :</strong> 32 - ⌈log₂(${neededAddresses})⌉ = /${newPrefix}<br>
          <strong>Bits sous-réseau :</strong> ${newPrefix} - ${prefix} = ${subnetBits} bits<br>
          <strong>Bits hôte :</strong> 32 - ${newPrefix} = ${32 - newPrefix} bits<br>
          <strong>Taille :</strong> 2<sup>${32-newPrefix}</sup> = ${subnetSize} adresses
        </div>
        <div class="binary-explanation">
          <strong>Structure binaire :</strong><br>
          ${createBinaryDisplay('Réseau', ipToBinary(intToIp(networkAddr)), prefix, subnetBits)}
          ${createBinaryDisplay('Masque', maskToBinary(newPrefix), prefix, subnetBits)}
          <div style="margin-top: 10px; font-size: 12px;">
            <span style="background: #2196F3; color: white; padding: 2px 5px;">Bits réseau (${prefix})</span>
            <span style="background: #4CAF50; color: white; padding: 2px 5px; margin-left: 5px;">Bits sous-réseau (${subnetBits})</span>
            <span style="background: #FF9800; color: white; padding: 2px 5px; margin-left: 5px;">Bits hôte (${32 - newPrefix})</span>
          </div>
        </div>
        <div class="calculation">
          <strong>Adresses :</strong><br>
          • Réseau: ${intToIp(networkAddr)}<br>
          • Première IP: ${intToIp(firstUsable)}<br>
          • Dernière IP: ${intToIp(lastUsable)}<br>
          • Broadcast: ${intToIp(broadcastAddr)}
        </div>
      `
    });
    
    // Stocker le résultat
    lastResult.push({
      SR: originalIndex + 1,
      Réseau: intToIp(networkAddr),
      Préfixe: `/${newPrefix}`,
      Hôtes: subnetSize - 2,
      Première_IP: intToIp(firstUsable),
      Dernière_IP: intToIp(lastUsable),
      Broadcast: intToIp(broadcastAddr),
      color: colors[originalIndex % colors.length],
      size: neededHosts,
      subnetSize: subnetSize
    });
    
    currentAddress += subnetSize;
  }
  
  // Trier les résultats
  lastResult.sort((a, b) => a.SR - b.SR);
  
  // Générer le tableau HTML
  lastResult.forEach(r => {
    resultHtml += `<tr style="background:${r.color}20;">
      <td>${r.SR}</td>
      <td>${r.Réseau}</td>
      <td>${r.Préfixe}</td>
      <td>${r.Hôtes}</td>
      <td>${r.Première_IP}</td>
      <td>${r.Dernière_IP}</td>
      <td>${r.Broadcast}</td>
    </tr>`;
  });
  
  resultHtml += "</table>";
  document.getElementById("result").innerHTML = resultHtml;
  document.getElementById("totalHosts").innerHTML = `<b>Total hôtes demandés :</b> ${totalHosts}`;
  
  // Afficher les explications
  displayCalculationExplanations();
  displayBinaryView();
  
  if (!hasOverflow) {
    drawBarGraph();
  }
}

// ------------------ Afficher les explications détaillées ------------------
function displayCalculationExplanations() {
  const container = document.getElementById("calculationExplanations");
  let html = '';
  
  calculationSteps.forEach(step => {
    html += `
      <div class="explanation-step">
        <h4>${step.title}</h4>
        ${step.content}
      </div>
    `;
  });
  
  container.innerHTML = html;
}

// ------------------ Afficher la vue binaire ------------------
function displayBinaryView() {
  const container = document.getElementById("binaryExplanations");
  let html = '';
  
  // Réseau principal
  const main = binaryData.find(d => d.type === 'main');
  html += `
    <div class="explanation-step">
      <h3>Réseau Principal</h3>
      <div class="binary-explanation">
        ${createBinaryDisplay('Adresse réseau', main.binaryNetwork, main.mask, 0)}
        ${createBinaryDisplay('Masque réseau', main.binaryMask, main.mask, 0)}
        <div class="calculation">
          <strong>Décimal :</strong> ${main.network}/${main.mask}<br>
          <strong>Bits réseau :</strong> ${main.mask}<br>
          <strong>Bits hôte :</strong> ${32 - main.mask}<br>
          <strong>Adresses disponibles :</strong> 2<sup>${32 - main.mask}</sup> = ${Math.pow(2, 32 - main.mask)}
        </div>
      </div>
    </div>
  `;
  
  // Sous-réseaux
  const subnets = binaryData.filter(d => d.type === 'subnet');
  html += `<div class="explanation-step">
    <h3>Sous-réseaux VLSM</h3>
    <p><em>Chaque sous-réseau emprunte des bits hôte pour créer des bits sous-réseau</em></p>`;
  
  subnets.forEach(subnet => {
    html += `
      <div style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">
        <h4>Sous-réseau ${subnet.sr} - ${subnet.network}/${subnet.mask}</h4>
        <div class="binary-explanation">
          ${createBinaryDisplay('Adresse', subnet.binaryNetwork, binaryData[0].mask, subnet.subnetBits)}
          ${createBinaryDisplay('Masque', subnet.binaryMask, binaryData[0].mask, subnet.subnetBits)}
          <div class="calculation">
            <strong>Structure :</strong><br>
            • Bits réseau: ${binaryData[0].mask} (fixe)<br>
            • Bits sous-réseau: ${subnet.subnetBits} (empruntés aux bits hôte)<br>
            • Bits hôte: ${subnet.hostBits} (restants)<br>
            • Taille: 2<sup>${subnet.hostBits}</sup> = ${Math.pow(2, subnet.hostBits)} adresses
          </div>
        </div>
      </div>
    `;
  });
  
  html += `</div>`;
  
  // Tableau récapitulatif
  html += `
    <div class="explanation-step">
      <h3>Récapitulatif des Bits</h3>
      <table style="width: 100%;">
        <tr>
          <th>Sous-réseau</th>
          <th>Bits Réseau</th>
          <th>Bits Sous-réseau</th>
          <th>Bits Hôte</th>
          <th>Total Bits</th>
          <th>Adresses</th>
        </tr>
        ${subnets.map(subnet => `
          <tr>
            <td>SR${subnet.sr}</td>
            <td>${binaryData[0].mask}</td>
            <td>${subnet.subnetBits}</td>
            <td>${subnet.hostBits}</td>
            <td>${binaryData[0].mask + subnet.subnetBits + subnet.hostBits}</td>
            <td>2<sup>${subnet.hostBits}</sup> = ${Math.pow(2, subnet.hostBits)}</td>
          </tr>
        `).join('')}
      </table>
    </div>
  `;
  
  container.innerHTML = html;
}

// ------------------ Barre graphique interactive ------------------
function drawBarGraph() {
  const container = document.getElementById("barContainer");
  container.innerHTML = "";
  
  if (lastResult.length === 0) return;
  
  const totalSize = lastResult.reduce((sum, r) => sum + r.subnetSize, 0);
  let offset = 0;
  const tooltip = document.getElementById("tooltip");
  
  lastResult.forEach(r => {
    const widthPercent = (r.subnetSize / totalSize) * 100;
    const div = document.createElement("div");
    div.className = "barSegment";
    div.style.left = offset + "%";
    div.style.width = widthPercent + "%";
    div.style.background = r.color;
    div.innerHTML = `SR${r.SR}`;
    
    div.addEventListener("mousemove", e => {
      tooltip.style.display = "block";
      tooltip.style.left = e.pageX + 10 + "px";
      tooltip.style.top = e.pageY + 10 + "px";
      tooltip.innerHTML = `
        <strong>Sous-réseau ${r.SR}</strong><br>
        Réseau: ${r.Réseau}<br>
        Masque: ${r.Préfixe}<br>
        Hôtes max: ${r.Hôtes}<br>
        Première IP: ${r.Première_IP}<br>
        Dernière IP: ${r.Dernière_IP}<br>
        Broadcast: ${r.Broadcast}
      `;
    });
    
    div.addEventListener("mouseleave", () => {
      tooltip.style.display = "none";
    });
    
    container.appendChild(div);
    offset += widthPercent;
  });
}

// ------------------ Export Excel ------------------
function exportExcel() {
  if (lastResult.length === 0) {
    alert("Calculez d'abord les sous-réseaux !");
    return;
  }
  
  const wb = XLSX.utils.book_new();
  const headers = ["SR", "Réseau", "Masque", "Hôtes max", "Première IP", "Dernière IP", "Broadcast"];
  const ws_data = [headers];
  
  lastResult.forEach(r => {
    ws_data.push([
      r.SR,
      r.Réseau,
      r.Préfixe,
      r.Hôtes,
      r.Première_IP,
      r.Dernière_IP,
      r.Broadcast
    ]);
  });
  
  const ws = XLSX.utils.aoa_to_sheet(ws_data);
  XLSX.utils.book_append_sheet(wb, ws, "Sous-réseaux");
  XLSX.writeFile(wb, "VLSM_Calcul.xlsx");
}

// ------------------ Export PDF ------------------
function exportPDF() {
  if (lastResult.length === 0) {
    alert("Calculez d'abord les sous-réseaux !");
    return;
  }
  
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  doc.setFontSize(16);
  doc.text("Calcul VLSM Professionnel", 10, 15);
  doc.setFontSize(12);
  
  let y = 30;
  lastResult.forEach(r => {
    if (y > 270) {
      doc.addPage();
      y = 20;
    }
    
    doc.text(`Sous-réseau ${r.SR}:`, 10, y);
    y += 7;
    doc.text(`  Réseau: ${r.Réseau}`, 15, y);
    y += 5;
    doc.text(`  Masque: ${r.Préfixe}`, 15, y);
    y += 5;
    doc.text(`  Hôtes: ${r.Hôtes}`, 15, y);
    y += 5;
    doc.text(`  Plage IP: ${r.Première_IP} - ${r.Dernière_IP}`, 15, y);
    y += 5;
    doc.text(`  Broadcast: ${r.Broadcast}`, 15, y);
    y += 10;
  });
  
  doc.save("VLSM_Calcul.pdf");
}

// Charger un exemple au démarrage
window.onload = function() {
  document.getElementById("network").value = "192.168.0.0";
  document.getElementById("mask").value = "/22";
  document.getElementById("nbSubnets").value = "4";
  generateHostInputs();
  
  setTimeout(() => {
    document.getElementById("hosts0").value = "250";
    document.getElementById("hosts1").value = "120";
    document.getElementById("hosts2").value = "60";
    document.getElementById("hosts3").value = "30";
  }, 100);
}
</script>
</body>
</html>


