<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Calculateur VLSM Professionnel avec Explications</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background: #f0f2f5; }
header { background: #4CAF50; color: #fff; padding: 20px; text-align: center; font-size: 24px; font-weight: bold; }
nav { background: #333; color: #fff; padding: 10px; position: sticky; top: 0; display: flex; gap: 15px; }
nav button { background: #555; border: none; padding: 8px 12px; color: #fff; cursor: pointer; border-radius: 4px; }
nav button:hover { background: #777; }
section { padding: 20px; }
label { display: inline-block; width: 160px; margin-top: 10px; }
input { margin: 5px; padding: 5px; width: 150px; }
button.action { margin: 5px; padding: 8px 12px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; }
button.action:hover { background: #45a049; }
table { border-collapse: collapse; width: 100%; margin-top: 20px; background: #fff; }
th, td { border: 1px solid #999; padding: 8px; text-align: center; }
th { background: #eee; }
#hostsInputs input { width: 80px; }
#barContainer { margin-top: 30px; width: 100%; height: 50px; background: #ddd; border-radius: 5px; position: relative; }
.barSegment { height: 100%; position: absolute; text-align: center; color: #fff; font-weight: bold; line-height: 50px; border-radius: 5px 0 0 5px; overflow: hidden; cursor: pointer; transition: all 0.2s; }
.barSegment:hover { opacity: 0.8; transform: scaleY(1.1); }
.tooltip { position: absolute; background: #333; color: #fff; padding: 5px 8px; border-radius: 4px; font-size: 12px; display: none; pointer-events: none; z-index: 1000; }
.alert { color: red; font-weight: bold; margin-top: 10px; }
.total { margin-top: 15px; font-weight: bold; font-size: 16px; }
.input-group { margin-bottom: 10px; }
.example { background: #e7f3ff; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 14px; }
.explanation { background: #fff3cd; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #ffc107; }
.explanation h3 { margin-top: 0; color: #856404; }
.explanation-step { margin: 10px 0; padding: 10px; background: #fff; border-radius: 4px; }
.calculation { font-family: monospace; background: #f8f9fa; padding: 5px; border-radius: 3px; margin: 5px 0; }
.formula { color: #d63384; font-weight: bold; }
</style>
</head>
<body>

<header>Calculateur VLSM Professionnel avec Explications</header>

<nav>
  <button onclick="scrollToSection('formSection')">Formulaire</button>
  <button onclick="scrollToSection('explanationSection')">Explications</button>
  <button onclick="scrollToSection('resultSection')">R√©sultats</button>
  <button onclick="scrollToSection('graphSection')">Graphique</button>
  <footer>Version Web (El azhari Amazzale Abdelhadi)</footer>
</nav>

<section id="formSection">
<h2>Saisie des donn√©es</h2>

<div class="example">
  <strong>Exemple :</strong> R√©seau: 192.168.0.0, Masque: /22, Sous-r√©seaux: 4, H√¥tes: 250, 120, 60, 30
</div>

<div class="input-group">
  <label>Adresse r√©seau :</label>
  <input type="text" id="network" placeholder="ex: 192.168.0.0">
</div>

<div class="input-group">
  <label>Masque :</label>
  <input type="text" id="mask" placeholder="ex: 255.255.252.0 ou /22">
</div>

<div class="input-group">
  <label>Nombre de sous-r√©seaux :</label>
  <input type="number" id="nbSubnets" min="1">
</div>

<div id="hostsInputs"></div>

<button class="action" onclick="generateHostInputs()">G√©n√©rer les champs</button>
<button class="action" onclick="calculateVLSM()">Calculer VLSM</button>
<button class="action" onclick="showExplanations()">Voir les explications</button>
<button class="action" onclick="exportExcel()">Exporter Excel</button>
<button class="action" onclick="exportPDF()">Exporter PDF</button>
<div id="alertContainer" class="alert"></div>
</section>

<section id="explanationSection" style="display: none;">
<h2>Explications d√©taill√©es du calcul VLSM</h2>
<div id="calculationExplanations"></div>
</section>

<section id="resultSection">
<h2>Tableau des sous-r√©seaux</h2>
<div id="result"></div>
<div id="totalHosts" class="total"></div>
</section>

<section id="graphSection">
<h2>Repr√©sentation graphique</h2>
<div id="barContainer"></div>
<div class="tooltip" id="tooltip"></div>
</section>

<script>
// ------------------ Variables globales ------------------
let lastResult = [];
let calculationSteps = [];

// ------------------ Navigation ------------------
function scrollToSection(id){
  document.getElementById(id).scrollIntoView({behavior:'smooth'});
}

// ------------------ Utilitaires ------------------
function maskToPrefix(mask) {
  if (!mask) return null;
  
  // Si le masque est d√©j√† en notation CIDR
  if (mask.startsWith("/")) {
    const prefix = parseInt(mask.slice(1));
    return (prefix >= 0 && prefix <= 32) ? prefix : null;
  }
  
  // Si le masque est en notation d√©cimale
  const parts = mask.split(".").map(Number);
  if (parts.length !== 4 || parts.some(p => isNaN(p) || p < 0 || p > 255)) {
    return null;
  }
  
  // Convertir en binaire
  const binary = parts.map(p => p.toString(2).padStart(8, "0")).join("");
  
  // V√©rifier que c'est un masque valide (s√©quence de 1 suivie de 0)
  const firstZero = binary.indexOf("0");
  if (firstZero === -1) return 32; // Tous des 1
  
  // V√©rifier qu'il n'y a pas de 1 apr√®s le premier 0
  if (binary.indexOf("1", firstZero) !== -1) {
    return null; // Masque invalide
  }
  
  return firstZero;
}

function ipToInt(ip) {
  if (!ip) return null;
  const parts = ip.split(".").map(Number);
  if (parts.length !== 4 || parts.some(p => isNaN(p) || p < 0 || p > 255)) {
    return null;
  }
  return parts.reduce((a, b) => a * 256 + b, 0);
}

function intToIp(int) {
  return [(int >> 24) & 255, (int >> 16) & 255, (int >> 8) & 255, int & 255].join(".");
}

function isValidIP(ip) {
  const regex = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!regex.test(ip)) return false;
  
  const parts = ip.split(".").map(Number);
  return parts.every(p => p >= 0 && p <= 255);
}

// ------------------ G√©n√©rer champs h√¥tes ------------------
function generateHostInputs() {
  const nb = parseInt(document.getElementById("nbSubnets").value);
  if (isNaN(nb) || nb < 1) {
    alert("Veuillez entrer un nombre valide de sous-r√©seaux");
    return;
  }
  
  const div = document.getElementById("hostsInputs");
  div.innerHTML = "";
  for (let i = 0; i < nb; i++) {
    div.innerHTML += `<div class="input-group">H√¥tes SR${i+1}: <input type="number" id="hosts${i}" min="1"></div>`;
  }
}

// ------------------ Afficher les explications ------------------
function showExplanations() {
  if (calculationSteps.length === 0) {
    alert("Calculez d'abord les sous-r√©seaux pour voir les explications !");
    return;
  }
  
  document.getElementById('explanationSection').style.display = 'block';
  scrollToSection('explanationSection');
}

// ------------------ Calcul VLSM avec explications ------------------
function calculateVLSM() {
  const network = document.getElementById("network").value.trim();
  const mask = document.getElementById("mask").value.trim();
  const nb = parseInt(document.getElementById("nbSubnets").value);
  const alertDiv = document.getElementById("alertContainer");
  alertDiv.innerHTML = "";
  calculationSteps = [];
  
  // Validation des entr√©es
  if (!network || !mask || isNaN(nb) || nb < 1) {
    alert("Remplissez tous les champs correctement");
    return;
  }
  
  if (!isValidIP(network)) {
    alert("Adresse r√©seau invalide");
    return;
  }
  
  const prefix = maskToPrefix(mask);
  if (prefix === null) {
    alert("Masque invalide");
    return;
  }
  
  const networkInt = ipToInt(network);
  if (networkInt === null) {
    alert("Adresse r√©seau invalide");
    return;
  }
  
  // R√©cup√©ration des nombres d'h√¥tes
  const hosts = [];
  for (let i = 0; i < nb; i++) {
    const hostInput = document.getElementById(`hosts${i}`);
    if (!hostInput) {
      alert("G√©n√©rez d'abord les champs pour les h√¥tes");
      return;
    }
    
    const h = parseInt(hostInput.value);
    if (isNaN(h) || h < 1) {
      alert(`Veuillez entrer un nombre valide d'h√¥tes pour le sous-r√©seau ${i+1}`);
      return;
    }
    hosts.push({hosts: h, index: i});
  }
  
  // Explication 1: Analyse du r√©seau principal
  calculationSteps.push({
    title: "1. Analyse du r√©seau principal",
    content: `
      <div class="calculation">
        <strong>R√©seau principal :</strong> ${network}/${prefix}<br>
        <strong>Adresse r√©seau :</strong> ${network}<br>
        <strong>Masque CIDR :</strong> /${prefix}<br>
        <strong>Nombre total d'adresses :</strong> 2<sup>${32-prefix}</sup> = ${Math.pow(2, 32-prefix)} adresses<br>
        <strong>Nombre d'h√¥tes utilisables :</strong> ${Math.pow(2, 32-prefix) - 2} h√¥tes<br>
        <strong>Plage d'adresses :</strong> ${network} - ${intToIp(networkInt + Math.pow(2, 32-prefix) - 1)}
      </div>
    `
  });
  
  // Tri d√©croissant pour l'allocation VLSM
  hosts.sort((a, b) => b.hosts - a.hosts);
  
  // Explication 2: Tri des sous-r√©seaux
  calculationSteps.push({
    title: "2. Tri des sous-r√©seaux par taille d√©croissante",
    content: `
      <div class="calculation">
        <strong>Sous-r√©seaux tri√©s :</strong><br>
        ${hosts.map((h, i) => `SR${h.index+1}: ${h.hosts} h√¥tes`).join('<br>')}
      </div>
      <p><em>Le VLSM n√©cessite de traiter d'abord les plus grands sous-r√©seaux pour optimiser l'espace d'adressage.</em></p>
    `
  });
  
  // Calcul des sous-r√©seaux
  lastResult = [];
  let resultHtml = "<table><tr><th>SR</th><th>R√©seau</th><th>Masque</th><th>H√¥tes max</th><th>Premi√®re IP</th><th>Derni√®re IP</th><th>Broadcast</th></tr>";
  let currentAddress = networkInt;
  let totalHosts = 0;
  const colors = ["#4CAF50", "#2196F3", "#FF9800", "#9C27B0", "#E91E63", "#00BCD4", "#FF5722", "#8BC34A"];
  
  // Calcul de la taille totale du r√©seau principal
  const totalNetworkSize = Math.pow(2, 32 - prefix);
  const networkEnd = networkInt + totalNetworkSize - 1;
  
  let hasOverflow = false;
  
  for (let i = 0; i < hosts.length; i++) {
    const neededHosts = hosts[i].hosts;
    const originalIndex = hosts[i].index;
    
    // Calcul du nouveau pr√©fixe pour ce sous-r√©seau
    const neededAddresses = neededHosts + 2;
    const newPrefix = 32 - Math.ceil(Math.log2(neededAddresses));
    const subnetSize = Math.pow(2, 32 - newPrefix);
    
    // Explication 3: Calcul du masque pour chaque sous-r√©seau
    calculationSteps.push({
      title: `3. Calcul du sous-r√©seau ${originalIndex + 1} (${neededHosts} h√¥tes)`,
      content: `
        <div class="calculation">
          <strong>Nombre d'h√¥tes demand√©s :</strong> ${neededHosts}<br>
          <strong>Adresses n√©cessaires :</strong> ${neededHosts} + 2 = ${neededAddresses} (h√¥tes + r√©seau + broadcast)<br>
          <strong>Calcul du pr√©fixe :</strong> 32 - ‚åàlog‚ÇÇ(${neededAddresses})‚åâ = 32 - ${Math.ceil(Math.log2(neededAddresses))} = /${newPrefix}<br>
          <strong>Taille du sous-r√©seau :</strong> 2<sup>${32-newPrefix}</sup> = ${subnetSize} adresses<br>
          <strong>H√¥tes utilisables :</strong> ${subnetSize} - 2 = ${subnetSize - 2} h√¥tes
        </div>
      `
    });
    
    // V√©rifier si nous d√©passons la capacit√© du r√©seau principal
    if (currentAddress + subnetSize > networkEnd + 1) {
      calculationSteps.push({
        title: "‚ö†Ô∏è Erreur : D√©passement de capacit√©",
        content: `
          <div class="calculation" style="color: red;">
            <strong>Le sous-r√©seau ${originalIndex + 1} d√©passe la capacit√© du r√©seau principal !</strong><br>
            Adresse de d√©but: ${intToIp(currentAddress)}<br>
            Taille requise: ${subnetSize} adresses<br>
            Fin du r√©seau principal: ${intToIp(networkEnd)}<br>
            <em>Solution : R√©duire le nombre d'h√¥tes ou utiliser un r√©seau principal plus grand.</em>
          </div>
        `
      });
      
      alertDiv.innerHTML = "‚ö†Ô∏è Attention : Le r√©seau principal est trop petit pour tous les sous-r√©seaux demand√©s !";
      hasOverflow = true;
      break;
    }
    
    // Calcul des adresses
    const networkAddr = currentAddress;
    const firstUsable = networkAddr + 1;
    const lastUsable = networkAddr + subnetSize - 2;
    const broadcastAddr = networkAddr + subnetSize - 1;
    
    totalHosts += neededHosts;
    
    // Explication 4: D√©tail des adresses
    calculationSteps.push({
      title: `4. Adresses du sous-r√©seau ${originalIndex + 1}`,
      content: `
        <div class="calculation">
          <strong>Adresse r√©seau :</strong> ${intToIp(networkAddr)}<br>
          <strong>Premi√®re IP utilisable :</strong> ${intToIp(firstUsable)}<br>
          <strong>Derni√®re IP utilisable :</strong> ${intToIp(lastUsable)}<br>
          <strong>Adresse broadcast :</strong> ${intToIp(broadcastAddr)}<br>
          <strong>Plage compl√®te :</strong> ${intToIp(networkAddr)} - ${intToIp(broadcastAddr)}
        </div>
      `
    });
    
    // Stocker le r√©sultat
    lastResult.push({
      SR: originalIndex + 1,
      R√©seau: intToIp(networkAddr),
      Pr√©fixe: `/${newPrefix}`,
      H√¥tes: subnetSize - 2,
      Premi√®re_IP: intToIp(firstUsable),
      Derni√®re_IP: intToIp(lastUsable),
      Broadcast: intToIp(broadcastAddr),
      color: colors[originalIndex % colors.length],
      size: neededHosts,
      subnetSize: subnetSize
    });
    
    // Passer √† l'adresse suivante
    currentAddress += subnetSize;
    
    // Explication 5: Passage au sous-r√©seau suivant
    if (i < hosts.length - 1) {
      calculationSteps.push({
        title: `5. Passage au sous-r√©seau suivant`,
        content: `
          <div class="calculation">
            <strong>Prochaine adresse disponible :</strong> ${intToIp(currentAddress)}<br>
            <strong>Adresses utilis√©es jusqu'√† pr√©sent :</strong> ${currentAddress - networkInt} sur ${totalNetworkSize}<br>
            <strong>Espace restant :</strong> ${totalNetworkSize - (currentAddress - networkInt)} adresses
          </div>
        `
      });
    }
  }
  
  // Trier les r√©sultats par ordre des sous-r√©seaux
  lastResult.sort((a, b) => a.SR - b.SR);
  
  // G√©n√©rer le tableau HTML
  lastResult.forEach(r => {
    resultHtml += `<tr style="background:${r.color}20;">
      <td>${r.SR}</td>
      <td>${r.R√©seau}</td>
      <td>${r.Pr√©fixe}</td>
      <td>${r.H√¥tes}</td>
      <td>${r.Premi√®re_IP}</td>
      <td>${r.Derni√®re_IP}</td>
      <td>${r.Broadcast}</td>
    </tr>`;
  });
  
  resultHtml += "</table>";
  document.getElementById("result").innerHTML = resultHtml;
  document.getElementById("totalHosts").innerHTML = `<b>Total h√¥tes demand√©s :</b> ${totalHosts}`;
  
  // Afficher les explications compl√®tes
  displayCalculationExplanations();
  
  if (!hasOverflow) {
    drawBarGraph();
  }
}

// ------------------ Afficher les explications d√©taill√©es ------------------
function displayCalculationExplanations() {
  const container = document.getElementById("calculationExplanations");
  let html = '';
  
  calculationSteps.forEach(step => {
    html += `
      <div class="explanation-step">
        <h4>${step.title}</h4>
        ${step.content}
      </div>
    `;
  });
  
  // Ajouter une conclusion
  html += `
    <div class="explanation-step">
      <h4>üéØ Conclusion</h4>
      <div class="calculation">
        <strong>R√©sum√© de l'allocation VLSM :</strong><br>
        ${lastResult.map(r => `SR${r.SR}: ${r.R√©seau}${r.Pr√©fixe} (${r.H√¥tes} h√¥tes)`).join('<br>')}<br><br>
        <strong>Total h√¥tes allou√©s :</strong> ${lastResult.reduce((sum, r) => sum + (r.H√¥tes), 0)}<br>
        <strong>Efficacit√© d'adressage :</strong> ${Math.round((lastResult.reduce((sum, r) => sum + r.size, 0) / lastResult.reduce((sum, r) => sum + r.H√¥tes, 0)) * 100)}%
      </div>
      <p><em>Le VLSM permet une allocation optimis√©e de l'espace d'adressage en adaptant la taille de chaque sous-r√©seau √† ses besoins r√©els.</em></p>
    </div>
  `;
  
  container.innerHTML = html;
}

// ------------------ Barre graphique interactive ------------------
function drawBarGraph() {
  const container = document.getElementById("barContainer");
  container.innerHTML = "";
  
  if (lastResult.length === 0) return;
  
  const totalSize = lastResult.reduce((sum, r) => sum + r.subnetSize, 0);
  let offset = 0;
  const tooltip = document.getElementById("tooltip");
  
  lastResult.forEach(r => {
    const widthPercent = (r.subnetSize / totalSize) * 100;
    const div = document.createElement("div");
    div.className = "barSegment";
    div.style.left = offset + "%";
    div.style.width = widthPercent + "%";
    div.style.background = r.color;
    div.innerHTML = `SR${r.SR}`;
    
    div.addEventListener("mousemove", e => {
      tooltip.style.display = "block";
      tooltip.style.left = e.pageX + 10 + "px";
      tooltip.style.top = e.pageY + 10 + "px";
      tooltip.innerHTML = `
        <strong>Sous-r√©seau ${r.SR}</strong><br>
        R√©seau: ${r.R√©seau}<br>
        Masque: ${r.Pr√©fixe}<br>
        H√¥tes max: ${r.H√¥tes}<br>
        Premi√®re IP: ${r.Premi√®re_IP}<br>
        Derni√®re IP: ${r.Derni√®re_IP}<br>
        Broadcast: ${r.Broadcast}
      `;
    });
    
    div.addEventListener("mouseleave", () => {
      tooltip.style.display = "none";
    });
    
    container.appendChild(div);
    offset += widthPercent;
  });
}

// ------------------ Export Excel ------------------
function exportExcel() {
  if (lastResult.length === 0) {
    alert("Calculez d'abord les sous-r√©seaux !");
    return;
  }
  
  const wb = XLSX.utils.book_new();
  const headers = ["SR", "R√©seau", "Masque", "H√¥tes max", "Premi√®re IP", "Derni√®re IP", "Broadcast"];
  const ws_data = [headers];
  
  lastResult.forEach(r => {
    ws_data.push([
      r.SR,
      r.R√©seau,
      r.Pr√©fixe,
      r.H√¥tes,
      r.Premi√®re_IP,
      r.Derni√®re_IP,
      r.Broadcast
    ]);
  });
  
  const ws = XLSX.utils.aoa_to_sheet(ws_data);
  XLSX.utils.book_append_sheet(wb, ws, "Sous-r√©seaux");
  XLSX.writeFile(wb, "VLSM_Calcul.xlsx");
}

// ------------------ Export PDF ------------------
function exportPDF() {
  if (lastResult.length === 0) {
    alert("Calculez d'abord les sous-r√©seaux !");
    return;
  }
  
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  doc.setFontSize(16);
  doc.text("Calcul VLSM Professionnel", 10, 15);
  doc.setFontSize(12);
  
  let y = 30;
  lastResult.forEach(r => {
    if (y > 270) {
      doc.addPage();
      y = 20;
    }
    
    doc.text(`Sous-r√©seau ${r.SR}:`, 10, y);
    y += 7;
    doc.text(`  R√©seau: ${r.R√©seau}`, 15, y);
    y += 5;
    doc.text(`  Masque: ${r.Pr√©fixe}`, 15, y);
    y += 5;
    doc.text(`  H√¥tes: ${r.H√¥tes}`, 15, y);
    y += 5;
    doc.text(`  Plage IP: ${r.Premi√®re_IP} - ${r.Derni√®re_IP}`, 15, y);
    y += 5;
    doc.text(`  Broadcast: ${r.Broadcast}`, 15, y);
    y += 10;
  });
  
  doc.save("VLSM_Calcul.pdf");
}

// Charger un exemple au d√©marrage
window.onload = function() {
  document.getElementById("network").value = "192.168.0.0";
  document.getElementById("mask").value = "/22";
  document.getElementById("nbSubnets").value = "4";
  generateHostInputs();
  
  // Remplir les champs d'exemple apr√®s un court d√©lai
  setTimeout(() => {
    document.getElementById("hosts0").value = "250";
    document.getElementById("hosts1").value = "120";
    document.getElementById("hosts2").value = "60";
    document.getElementById("hosts3").value = "30";
  }, 100);
}
</script>
</body>
</html>

